from typing import List, Dict
import json
import re
from src.core.orchestrator import APIEndpoint, AgentMessage


class SpecGeneratorAgent:
    """Agent responsible for generating OpenAPI specifications from discovered APIs"""

    def __init__(self):
        self.spec_version = "3.0.0"
        self.base_spec = {
            "openapi": self.spec_version,
            "info": {
                "title": "Auto-Generated API",
                "version": "1.0.0",
                "description": "API specification automatically generated by API Orchestrator",
            },
            "servers": [
                {"url": "http://localhost:8000", "description": "Development server"}
            ],
            "paths": {},
            "components": {"schemas": {}, "securitySchemes": {}, "parameters": {}},
        }

    async def generate(self, apis: List[APIEndpoint], options: Dict = None) -> Dict:
        """Generate OpenAPI specification from discovered APIs"""
        spec = self.base_spec.copy()

        # Update info if provided
        if options:
            if "title" in options:
                spec["info"]["title"] = options["title"]
            if "version" in options:
                spec["info"]["version"] = options["version"]
            if "description" in options:
                spec["info"]["description"] = options["description"]
            if "servers" in options:
                spec["servers"] = options["servers"]

        # Group APIs by path
        paths = {}
        for api in apis:
            if api.path not in paths:
                paths[api.path] = {}

            # Create operation object
            operation = self._create_operation(api)
            paths[api.path][api.method.lower()] = operation

        spec["paths"] = paths

        # Generate common schemas
        spec["components"]["schemas"] = self._generate_schemas(apis)

        # Add security schemes if auth is detected
        if any(api.auth_required for api in apis):
            spec["components"]["securitySchemes"] = self._generate_security_schemes()

        print(f"âœ“ Generated OpenAPI spec with {len(paths)} paths")
        return spec

    def _create_operation(self, api: APIEndpoint) -> Dict:
        """Create an OpenAPI operation object for an endpoint"""
        operation = {
            "operationId": api.handler_name,
            "summary": self._generate_summary(api),
            "description": api.description or self._generate_description(api),
            "tags": self._extract_tags(api.path),
            "parameters": [],
            "responses": {},
        }

        # Add path parameters
        path_params = self._extract_path_parameters(api.path)
        for param in path_params:
            operation["parameters"].append(
                {
                    "name": param,
                    "in": "path",
                    "required": True,
                    "schema": {"type": self._infer_param_type(param)},
                    "description": f"The {param} parameter",
                }
            )

        # Add query/body parameters
        if api.parameters:
            for param in api.parameters:
                if api.method in ["POST", "PUT", "PATCH"]:
                    # For write operations, parameters go in request body
                    if "requestBody" not in operation:
                        operation["requestBody"] = {
                            "required": True,
                            "content": {
                                "application/json": {
                                    "schema": {"type": "object", "properties": {}}
                                }
                            },
                        }
                    schema = operation["requestBody"]["content"]["application/json"][
                        "schema"
                    ]
                    schema["properties"][param["name"]] = {
                        "type": param.get("type", "string"),
                        "description": param.get(
                            "description", f"The {param['name']} field"
                        ),
                    }
                else:
                    # For read operations, parameters are query params
                    operation["parameters"].append(
                        {
                            "name": param["name"],
                            "in": "query",
                            "required": False,
                            "schema": {"type": param.get("type", "string")},
                            "description": param.get(
                                "description", f"The {param['name']} parameter"
                            ),
                        }
                    )

        # Add responses
        operation["responses"] = self._generate_responses(api)

        # Add security if required
        if api.auth_required:
            operation["security"] = [{"bearerAuth": []}]

        return operation

    def _extract_path_parameters(self, path: str) -> List[str]:
        """Extract parameter names from path like /users/{user_id}"""
        # Match {param} or :param patterns
        pattern = r"\{([^}]+)\}|:([^/]+)"
        matches = re.findall(pattern, path)
        params = []
        for match in matches:
            param = match[0] if match[0] else match[1]
            params.append(param)
        return params

    def _infer_param_type(self, param_name: str) -> str:
        """Infer parameter type from its name"""
        if "id" in param_name.lower():
            return "string"  # Could be UUID
        elif any(
            word in param_name.lower()
            for word in ["count", "number", "age", "size", "limit"]
        ):
            return "integer"
        elif any(
            word in param_name.lower() for word in ["price", "amount", "cost", "rate"]
        ):
            return "number"
        elif any(
            word in param_name.lower() for word in ["is_", "has_", "enabled", "active"]
        ):
            return "boolean"
        else:
            return "string"

    def _extract_tags(self, path: str) -> List[str]:
        """Extract tags from path for grouping operations"""
        parts = path.strip("/").split("/")
        tags = []

        # Use first path segment as tag if not a parameter
        if parts and not parts[0].startswith("{") and not parts[0].startswith(":"):
            tag = parts[0].capitalize()
            # Singularize if it's plural
            if tag.endswith("s"):
                tag = tag[:-1]
            tags.append(tag)
        else:
            tags.append("Default")

        return tags

    def _generate_summary(self, api: APIEndpoint) -> str:
        """Generate a summary from the endpoint"""
        # Extract resource from path
        path_parts = api.path.strip("/").split("/")
        resource = "resource"

        for part in path_parts:
            if not part.startswith("{") and not part.startswith(":"):
                resource = part
                break

        # Generate summary based on method
        method_summaries = {
            "GET": f"Retrieve {resource}",
            "POST": f"Create new {resource}",
            "PUT": f"Update {resource}",
            "PATCH": f"Partially update {resource}",
            "DELETE": f"Delete {resource}",
            "HEAD": f"Check {resource} headers",
            "OPTIONS": f"Get {resource} options",
        }

        return method_summaries.get(api.method, f"{api.method} {resource}")

    def _generate_description(self, api: APIEndpoint) -> str:
        """Generate a description for the endpoint"""
        return f"This endpoint handles {api.method} requests to {api.path}"

    def _generate_responses(self, api: APIEndpoint) -> Dict:
        """Generate response schemas for an endpoint"""
        responses = {}

        # Success responses
        if api.method == "GET":
            responses["200"] = {
                "description": "Successful response",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "properties": {
                                "data": {
                                    "type": "object",
                                    "description": "The requested resource",
                                }
                            },
                        }
                    }
                },
            }
        elif api.method == "POST":
            responses["201"] = {
                "description": "Resource created successfully",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "properties": {
                                "id": {"type": "string"},
                                "message": {"type": "string"},
                            },
                        }
                    }
                },
            }
        elif api.method in ["PUT", "PATCH"]:
            responses["200"] = {
                "description": "Resource updated successfully",
                "content": {
                    "application/json": {
                        "schema": {
                            "type": "object",
                            "properties": {
                                "message": {"type": "string"},
                                "data": {"type": "object"},
                            },
                        }
                    }
                },
            }
        elif api.method == "DELETE":
            responses["204"] = {"description": "Resource deleted successfully"}
        else:
            responses["200"] = {"description": "Successful response"}

        # Common error responses
        responses["400"] = {
            "description": "Bad request",
            "content": {
                "application/json": {"schema": {"$ref": "#/components/schemas/Error"}}
            },
        }

        if api.auth_required:
            responses["401"] = {
                "description": "Unauthorized",
                "content": {
                    "application/json": {
                        "schema": {"$ref": "#/components/schemas/Error"}
                    }
                },
            }

        responses["404"] = {
            "description": "Resource not found",
            "content": {
                "application/json": {"schema": {"$ref": "#/components/schemas/Error"}}
            },
        }

        responses["500"] = {
            "description": "Internal server error",
            "content": {
                "application/json": {"schema": {"$ref": "#/components/schemas/Error"}}
            },
        }

        return responses

    def _generate_schemas(self, apis: List[APIEndpoint]) -> Dict:
        """Generate common schemas used across the API"""
        schemas = {
            "Error": {
                "type": "object",
                "properties": {
                    "error": {"type": "string", "description": "Error message"},
                    "code": {"type": "integer", "description": "Error code"},
                    "details": {
                        "type": "object",
                        "description": "Additional error details",
                    },
                },
                "required": ["error"],
            }
        }

        # Generate schemas based on paths
        resources = set()
        for api in apis:
            parts = api.path.strip("/").split("/")
            for part in parts:
                if not part.startswith("{") and not part.startswith(":"):
                    resources.add(part.capitalize().rstrip("s"))

        # Create basic schemas for each resource
        for resource in resources:
            schemas[resource] = {
                "type": "object",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": f"Unique identifier for the {resource}",
                    },
                    "created_at": {
                        "type": "string",
                        "format": "date-time",
                        "description": "Creation timestamp",
                    },
                    "updated_at": {
                        "type": "string",
                        "format": "date-time",
                        "description": "Last update timestamp",
                    },
                },
            }

        return schemas

    def _generate_security_schemes(self) -> Dict:
        """Generate security schemes for the API"""
        return {
            "bearerAuth": {
                "type": "http",
                "scheme": "bearer",
                "bearerFormat": "JWT",
                "description": "JWT authentication token",
            },
            "apiKey": {
                "type": "apiKey",
                "in": "header",
                "name": "X-API-Key",
                "description": "API key authentication",
            },
        }

    async def handle_message(self, message: AgentMessage):
        """Handle messages from other agents"""
        if message.action == "regenerate_spec":
            # Regenerate spec with new options
            apis = message.payload.get("apis", [])
            options = message.payload.get("options", {})
            await self.generate(apis, options)

    def export_to_yaml(self, spec: Dict) -> str:
        """Export spec to YAML format"""
        import yaml

        return yaml.dump(spec, default_flow_style=False, sort_keys=False)

    def export_to_json(self, spec: Dict) -> str:
        """Export spec to JSON format"""
        return json.dumps(spec, indent=2)

    def validate_spec(self, spec: Dict) -> List[str]:
        """Validate the generated specification"""
        errors = []

        # Check required fields
        if "openapi" not in spec:
            errors.append("Missing 'openapi' field")
        if "info" not in spec:
            errors.append("Missing 'info' field")
        if "paths" not in spec:
            errors.append("Missing 'paths' field")

        # Validate paths
        if "paths" in spec:
            for path, methods in spec["paths"].items():
                if not path.startswith("/"):
                    errors.append(f"Path '{path}' must start with '/'")

        return errors
